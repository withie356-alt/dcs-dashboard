// DCS ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ - ë³´ì•ˆ ê°•í™” ë²„ì „
class DCSRealTimeDashboard {
    constructor() {
        // API ì—”ë“œí¬ì¸íŠ¸ (ë°±ì—”ë“œ ì„œë²„)
        this.apiBaseUrl = window.location.origin + '/api';
        
        // ëŒ€ì‹œë³´ë“œ ìƒíƒœ
        this.state = {
            selectedTags: [],
            availableTags: [],
            widgets: new Map(),
            layout: 'auto',
            autoRefresh: false,
            refreshInterval: 10000, // 10ì´ˆ
            refreshTimer: null,
            connectionStatus: 'disconnected',
            chartData: new Map(),
            maxDataPoints: 100,
            lastUpdateTime: null,
            dataCache: new Map(),
            eventSources: new Map() // SSE ì—°ê²° ê´€ë¦¬
        };

        // ì €ì¥ëœ ë ˆì´ì•„ì›ƒ
        this.savedLayouts = [];

        // ì´ˆê¸°í™”
        this.init();
    }

    async init() {
        try {
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì´ì „ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
            this.loadPreviousState();

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            this.setupEventListeners();

            // ì„œë²„ í—¬ìŠ¤ ì²´í¬
            await this.checkServerHealth();

            // ì €ì¥ëœ ë ˆì´ì•„ì›ƒ ë¶ˆëŸ¬ì˜¤ê¸°
            await this.loadSavedLayouts();

            // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
            if (this.state.selectedTags.length > 0) {
                await this.refreshData();
            }

            this.showNotification('ëŒ€ì‹œë³´ë“œê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        } catch (error) {
            console.error('ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
            this.showNotification('ëŒ€ì‹œë³´ë“œ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
        }
    }

    async checkServerHealth() {
        try {
            const response = await fetch(`${this.apiBaseUrl.replace('/api', '')}/health`);
            const data = await response.json();
            
            if (data.status === 'healthy') {
                this.updateConnectionStatus('connected');
            } else {
                throw new Error('Server unhealthy');
            }
        } catch (error) {
            this.updateConnectionStatus('disconnected');
            throw error;
        }
    }

    setupEventListeners() {
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
        window.addEventListener('resize', () => {
            this.adjustLayout();
        });

        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ SSE ì—°ê²° ì •ë¦¬
        window.addEventListener('beforeunload', () => {
            this.closeAllEventSources();
        });

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                switch(e.key) {
                    case 'r':
                        e.preventDefault();
                        this.refreshData();
                        break;
                    case 's':
                        e.preventDefault();
                        this.saveLayout();
                        break;
                    case 'l':
                        e.preventDefault();
                        this.loadLayout();
                        break;
                    case 'a':
                        e.preventDefault();
                        this.openTagSelector();
                        break;
                }
            }
        });

        // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ê°ì§€
        window.addEventListener('online', () => {
            this.showNotification('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ë¨', 'success');
            this.refreshData();
        });

        window.addEventListener('offline', () => {
            this.showNotification('ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€', 'error');
            this.updateConnectionStatus('disconnected');
        });
    }

    // ê³„ê¸° ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (localStorage ìºì‹± ì§€ì›)
    async loadAvailableTags(forceRefresh = false) {
        try {
            // ìºì‹œëœ ë°ì´í„° í™•ì¸
            if (!forceRefresh) {
                const cached = localStorage.getItem('dcs_available_tags');
                const cacheTime = localStorage.getItem('dcs_tags_cache_time');

                if (cached && cacheTime) {
                    const cacheAge = Date.now() - parseInt(cacheTime);
                    // 1ì‹œê°„ ì´ë‚´ ìºì‹œëŠ” ìœ íš¨
                    if (cacheAge < 3600000) {
                        this.state.availableTagsData = JSON.parse(cached);
                        this.state.availableTags = this.state.availableTagsData.map(t => t.tag_name);
                        this.displayAvailableTags();
                        console.log('ìºì‹œëœ íƒœê·¸ ëª©ë¡ ì‚¬ìš© (ìºì‹œ ë‚˜ì´:', Math.floor(cacheAge/1000), 'ì´ˆ)');
                        return;
                    }
                }
            }

            this.showNotification('ê³„ê¸° ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...', 'info');

            const response = await fetch(`${this.apiBaseUrl}/meta`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();

            if (result.success && result.data) {
                // ì „ì²´ íƒœê·¸ ì •ë³´ ì €ì¥ (tag_name, tag_desc, company)
                this.state.availableTagsData = result.data;
                this.state.availableTags = result.data.map(t => t.tag_name);

                // localStorageì— ìºì‹±
                localStorage.setItem('dcs_available_tags', JSON.stringify(result.data));
                localStorage.setItem('dcs_tags_cache_time', Date.now().toString());

                this.displayAvailableTags();
                this.showNotification(`${this.state.availableTags.length}ê°œì˜ ê³„ê¸°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`, 'success');
            } else {
                throw new Error(result.message || 'íƒœê·¸ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('íƒœê·¸ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', error);
            this.showNotification('ê³„ê¸° ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
        }
    }

    extractTagNames(data) {
        // Lambda ì‘ë‹µ êµ¬ì¡°ì— ë”°ë¼ íƒœê·¸ ì´ë¦„ ì¶”ì¶œ
        // ì‹¤ì œ ë°ì´í„° êµ¬ì¡°ì— ë§ê²Œ ìˆ˜ì • í•„ìš”
        if (Array.isArray(data)) {
            return data.map(item => item.tag_name || item);
        } else if (data.tags) {
            return data.tags;
        } else if (data.columns) {
            // ì»¬ëŸ¼ ì •ë³´ì—ì„œ íƒœê·¸ ì¶”ì¶œ
            return data.columns.filter(col => col !== 'timestamp');
        }
        return [];
    }

    displayAvailableTags() {
        const tagList = document.getElementById('tagList');
        tagList.innerHTML = '';

        if (this.state.availableTags.length === 0) {
            tagList.innerHTML = '<p style="text-align: center; color: #999;">ì‚¬ìš© ê°€ëŠ¥í•œ ê³„ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
            return;
        }

        // íšŒì‚¬ë³„ë¡œ ê·¸ë£¹í•‘
        const groupedByCompany = {};
        this.state.availableTagsData.forEach(tagData => {
            const company = tagData.company || 'unknown';
            if (!groupedByCompany[company]) {
                groupedByCompany[company] = [];
            }
            groupedByCompany[company].push(tagData);
        });

        // íšŒì‚¬ë³„ë¡œ í‘œì‹œ
        Object.entries(groupedByCompany).sort().forEach(([company, tags]) => {
            // íšŒì‚¬ í—¤ë”
            const groupHeader = document.createElement('h3');
            groupHeader.textContent = company.toUpperCase();
            groupHeader.style.cssText = 'grid-column: 1/-1; margin: 15px 0 10px 0; color: #667eea; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 5px;';
            tagList.appendChild(groupHeader);

            // í•´ë‹¹ íšŒì‚¬ì˜ íƒœê·¸ë“¤
            tags.forEach(tagData => {
                const tagName = tagData.tag_name;
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                if (this.state.selectedTags.includes(tagName)) {
                    tagItem.classList.add('selected');
                }

                tagItem.innerHTML = `
                    <div style="font-weight: 600; color: #333;">${tagName}</div>
                    <div style="font-size: 12px; color: #666; margin-top: 4px;">${tagData.tag_desc || 'ì„¤ëª… ì—†ìŒ'}</div>
                `;

                tagItem.onclick = () => this.toggleTagSelection(tagName, tagItem);
                tagList.appendChild(tagItem);
            });
        });
    }

    groupTags(tags) {
        const groups = { default: [] };
        
        tags.forEach(tag => {
            // íƒœê·¸ ì´ë¦„ íŒ¨í„´ìœ¼ë¡œ ê·¸ë£¹í™” (ì˜ˆ: FIT_, TIT_, PIT_ ë“±)
            const match = tag.match(/^([A-Z]+)_/);
            if (match) {
                const prefix = match[1];
                if (!groups[prefix]) {
                    groups[prefix] = [];
                }
                groups[prefix].push(tag);
            } else {
                groups.default.push(tag);
            }
        });

        return groups;
    }

    getTagDescription(tag) {
        // íƒœê·¸ íƒ€ì…ë³„ ì„¤ëª…
        const descriptions = {
            'FIT': 'ìœ ëŸ‰ê³„',
            'TIT': 'ì˜¨ë„ê³„',
            'PIT': 'ì••ë ¥ê³„',
            'LIT': 'ë ˆë²¨ê³„',
            'FCV': 'ìœ ëŸ‰ ì œì–´ ë°¸ë¸Œ',
            'TCV': 'ì˜¨ë„ ì œì–´ ë°¸ë¸Œ',
            'PCV': 'ì••ë ¥ ì œì–´ ë°¸ë¸Œ',
            'LCV': 'ë ˆë²¨ ì œì–´ ë°¸ë¸Œ'
        };

        for (const [prefix, desc] of Object.entries(descriptions)) {
            if (tag.startsWith(prefix)) {
                return desc;
            }
        }
        return 'ê³„ì¸¡ê¸°';
    }

    toggleTagSelection(tag, element) {
        if (this.state.selectedTags.includes(tag)) {
            this.state.selectedTags = this.state.selectedTags.filter(t => t !== tag);
            element.classList.remove('selected');
        } else {
            this.state.selectedTags.push(tag);
            element.classList.add('selected');
        }
    }

    applySelectedTags() {
        this.closeModal('tagSelectorModal');
        this.renderWidgets();
        
        if (this.state.autoRefresh) {
            this.startAutoRefresh();
        } else {
            this.refreshData();
        }
        
        this.saveState();
    }

    // ìœ„ì ¯ ë Œë”ë§
    renderWidgets() {
        const grid = document.getElementById('dashboardGrid');
        grid.innerHTML = '';
        
        // ê¸°ì¡´ SSE ì—°ê²° ì¢…ë£Œ
        this.closeAllEventSources();
        
        this.state.widgets.clear();
        this.state.chartData.clear();

        this.state.selectedTags.forEach(tag => {
            const widget = this.createWidget(tag);
            grid.appendChild(widget);
            this.state.widgets.set(tag, widget);
            
            // ì°¨íŠ¸ ì´ˆê¸°í™”
            this.initChart(tag);
            
            // ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì—°ê²° (ì˜µì…˜)
            if (this.state.autoRefresh) {
                this.connectEventSource(tag);
            }
        });

        this.adjustLayout();
    }

    createWidget(tagName) {
        const widget = document.createElement('div');
        widget.className = 'widget';
        widget.id = `widget-${tagName.replace(/[^a-z0-9]/gi, '-')}`;
        
        widget.innerHTML = `
            <div class="widget-header">
                <div class="widget-title">
                    ${tagName}
                    <span style="font-size: 12px; color: #999; margin-left: 8px;">${this.getTagDescription(tagName)}</span>
                </div>
                <div class="widget-actions">
                    <button class="widget-btn" onclick="dashboard.toggleChartType('${tagName}')" title="ì°¨íŠ¸ íƒ€ì…">ğŸ“Š</button>
                    <button class="widget-btn" onclick="dashboard.refreshTag('${tagName}')" title="ìƒˆë¡œê³ ì¹¨">ğŸ”„</button>
                    <button class="widget-btn" onclick="dashboard.removeWidget('${tagName}')" title="ì œê±°">âœ•</button>
                </div>
            </div>
            <div class="widget-content">
                <div class="loading">
                    <div class="spinner"></div>
                </div>
                <div class="widget-value" style="display:none;">
                    <span id="value-${tagName.replace(/[^a-z0-9]/gi, '-')}">--</span>
                    <span class="widget-unit" id="unit-${tagName.replace(/[^a-z0-9]/gi, '-')}"></span>
                </div>
                <div class="widget-chart">
                    <canvas id="chart-${tagName.replace(/[^a-z0-9]/gi, '-')}"></canvas>
                </div>
                <div class="widget-info">
                    <span id="min-${tagName.replace(/[^a-z0-9]/gi, '-')}">ìµœì†Œ: --</span>
                    <span id="max-${tagName.replace(/[^a-z0-9]/gi, '-')}">ìµœëŒ€: --</span>
                    <span id="avg-${tagName.replace(/[^a-z0-9]/gi, '-')}">í‰ê· : --</span>
                </div>
                <div class="widget-info" style="margin-top: 5px;">
                    <span id="time-${tagName.replace(/[^a-z0-9]/gi, '-')}">--:--:--</span>
                    <span id="status-${tagName.replace(/[^a-z0-9]/gi, '-')}" style="color: #999;">ëŒ€ê¸°ì¤‘</span>
                </div>
            </div>
        `;
        
        return widget;
    }

    initChart(tagName) {
        const safeId = tagName.replace(/[^a-z0-9]/gi, '-');
        const ctx = document.getElementById(`chart-${safeId}`).getContext('2d');
        
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: tagName,
                    data: [],
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 0,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 5
                        }
                    },
                    y: {
                        display: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });
        
        this.state.chartData.set(tagName, {
            chart: chart,
            data: [],
            timestamps: [],
            chartType: 'line'
        });
    }

    // ë°ì´í„° ìƒˆë¡œê³ ì¹¨
    async refreshData() {
        if (this.state.selectedTags.length === 0) {
            this.showNotification('ëª¨ë‹ˆí„°ë§í•  ê³„ê¸°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
            return;
        }

        try {
            const now = new Date();
            const fromDate = new Date(now.getTime() - 24 * 3600000); // 24ì‹œê°„ ì „
            
            const requestBody = {
                exec_from_dt: this.formatDate(fromDate),
                exec_to_dt: this.formatDate(now),
                tag_names: this.state.selectedTags
            };

            const response = await fetch(`${this.apiBaseUrl}/data`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            
            if (result.success && result.data) {
                this.processData(result.data);
                this.state.lastUpdateTime = new Date();
                this.updateConnectionStatus('connected');
            } else {
                throw new Error(result.message || 'ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
            
        } catch (error) {
            console.error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
            this.showNotification('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
            this.updateConnectionStatus('disconnected');
        }
    }

    async refreshTag(tagName) {
        try {
            const now = new Date();
            const fromDate = new Date(now.getTime() - 24 * 3600000);
            
            const requestBody = {
                exec_from_dt: this.formatDate(fromDate),
                exec_to_dt: this.formatDate(now),
                tag_names: [tagName]
            };

            const response = await fetch(`${this.apiBaseUrl}/data`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            const result = await response.json();
            
            if (result.success && result.data) {
                this.processTagData(tagName, result.data);
            }
        } catch (error) {
            console.error(`Failed to refresh ${tagName}:`, error);
        }
    }

    processData(data) {
        // ë°ì´í„° êµ¬ì¡° íŒŒì‹± ë° ì²˜ë¦¬
        this.state.selectedTags.forEach(tagName => {
            this.processTagData(tagName, data);
        });
    }

    processTagData(tagName, data) {
        const safeId = tagName.replace(/[^a-z0-9]/gi, '-');
        
        // ë°ì´í„° ì¶”ì¶œ (ì‹¤ì œ ë°ì´í„° êµ¬ì¡°ì— ë§ê²Œ ìˆ˜ì • í•„ìš”)
        let values = [];
        let timestamps = [];
        
        if (Array.isArray(data)) {
            data.forEach(item => {
                if (item[tagName] !== undefined && item[tagName] !== null) {
                    values.push(parseFloat(item[tagName]));
                    timestamps.push(item.timestamp || item.exec_tm || new Date().toISOString());
                }
            });
        } else if (data[tagName]) {
            values = data[tagName];
            timestamps = data.timestamps || values.map((_, i) => new Date(Date.now() - i * 3600000).toISOString());
        }

        if (values.length === 0) {
            console.warn(`No data for tag: ${tagName}`);
            return;
        }

        // í†µê³„ ê³„ì‚°
        const min = Math.min(...values);
        const max = Math.max(...values);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const lastValue = values[values.length - 1];

        // UI ì—…ë°ì´íŠ¸
        this.updateWidget(tagName, lastValue, timestamps[timestamps.length - 1], { min, max, avg });

        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        this.updateChart(tagName, values, timestamps);

        // ë¡œë”© ìˆ¨ê¸°ê¸°
        const widget = document.getElementById(`widget-${safeId}`);
        if (widget) {
            widget.querySelector('.loading').style.display = 'none';
            widget.querySelector('.widget-value').style.display = 'block';
        }
    }

    updateWidget(tagName, value, timestamp, stats = {}) {
        const safeId = tagName.replace(/[^a-z0-9]/gi, '-');
        
        // ê°’ ì—…ë°ì´íŠ¸
        const valueEl = document.getElementById(`value-${safeId}`);
        if (valueEl) {
            valueEl.textContent = typeof value === 'number' ? value.toFixed(2) : value;
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        if (stats.min !== undefined) {
            const minEl = document.getElementById(`min-${safeId}`);
            if (minEl) minEl.textContent = `ìµœì†Œ: ${stats.min.toFixed(2)}`;
        }

        if (stats.max !== undefined) {
            const maxEl = document.getElementById(`max-${safeId}`);
            if (maxEl) maxEl.textContent = `ìµœëŒ€: ${stats.max.toFixed(2)}`;
        }

        if (stats.avg !== undefined) {
            const avgEl = document.getElementById(`avg-${safeId}`);
            if (avgEl) avgEl.textContent = `í‰ê· : ${stats.avg.toFixed(2)}`;
        }

        // ì‹œê°„ ì—…ë°ì´íŠ¸
        const timeEl = document.getElementById(`time-${safeId}`);
        if (timeEl) {
            const time = new Date(timestamp);
            timeEl.textContent = time.toLocaleTimeString('ko-KR');
        }

        // ìƒíƒœ ì—…ë°ì´íŠ¸
        const statusEl = document.getElementById(`status-${safeId}`);
        if (statusEl) {
            statusEl.textContent = 'ì—…ë°ì´íŠ¸ë¨';
            statusEl.style.color = '#4ade80';
            setTimeout(() => {
                statusEl.textContent = 'ì •ìƒ';
                statusEl.style.color = '#999';
            }, 2000);
        }
    }

    updateChart(tagName, values, timestamps) {
        const chartData = this.state.chartData.get(tagName);
        if (!chartData) return;

        // ë°ì´í„° ì œí•œ
        const maxPoints = this.state.maxDataPoints;
        if (values.length > maxPoints) {
            values = values.slice(-maxPoints);
            timestamps = timestamps.slice(-maxPoints);
        }

        // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
        chartData.chart.data.labels = timestamps.map(ts => {
            const date = new Date(ts);
            return date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        });
        
        chartData.chart.data.datasets[0].data = values;
        chartData.chart.update('none'); // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì—…ë°ì´íŠ¸

        // ë°ì´í„° ìºì‹œ ì €ì¥
        chartData.data = values;
        chartData.timestamps = timestamps;
    }

    // Server-Sent Events ì—°ê²°
    connectEventSource(tagName) {
        if (this.state.eventSources.has(tagName)) {
            this.state.eventSources.get(tagName).close();
        }

        const eventSource = new EventSource(`${this.apiBaseUrl}/stream/${tagName}`);
        
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleRealtimeUpdate(data);
        };

        eventSource.onerror = (error) => {
            console.error(`SSE error for ${tagName}:`, error);
            eventSource.close();
            this.state.eventSources.delete(tagName);
        };

        this.state.eventSources.set(tagName, eventSource);
    }

    handleRealtimeUpdate(data) {
        const { tagName, value, timestamp } = data;
        
        // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
        const chartData = this.state.chartData.get(tagName);
        if (chartData) {
            // ìƒˆ ë°ì´í„° ì¶”ê°€
            chartData.data.push(value);
            chartData.timestamps.push(timestamp);
            
            // ë°ì´í„° ì œí•œ
            if (chartData.data.length > this.state.maxDataPoints) {
                chartData.data.shift();
                chartData.timestamps.shift();
            }
            
            // UI ì—…ë°ì´íŠ¸
            this.updateWidget(tagName, value, timestamp);
            this.updateChart(tagName, chartData.data, chartData.timestamps);
        }
    }

    closeAllEventSources() {
        this.state.eventSources.forEach(es => es.close());
        this.state.eventSources.clear();
    }

    // ìë™ ìƒˆë¡œê³ ì¹¨
    toggleAutoRefresh() {
        this.state.autoRefresh = !this.state.autoRefresh;
        const toggle = document.getElementById('autoRefreshToggle');
        
        if (this.state.autoRefresh) {
            toggle.classList.add('active');
            this.startAutoRefresh();
            this.showNotification('ìë™ ìƒˆë¡œê³ ì¹¨ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        } else {
            toggle.classList.remove('active');
            this.stopAutoRefresh();
            this.closeAllEventSources();
            this.showNotification('ìë™ ìƒˆë¡œê³ ì¹¨ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        }
        
        this.saveState();
    }

    startAutoRefresh() {
        this.stopAutoRefresh();
        
        // SSE ì‚¬ìš© ê°€ëŠ¥ ì‹œ SSE ì—°ê²°
        if (window.EventSource) {
            this.state.selectedTags.forEach(tag => {
                this.connectEventSource(tag);
            });
        } else {
            // SSE ë¯¸ì§€ì› ì‹œ í´ë§
            this.state.refreshTimer = setInterval(() => {
                this.refreshData();
            }, this.state.refreshInterval);
        }
    }

    stopAutoRefresh() {
        if (this.state.refreshTimer) {
            clearInterval(this.state.refreshTimer);
            this.state.refreshTimer = null;
        }
    }

    // ë ˆì´ì•„ì›ƒ ê´€ë¦¬
    setLayout(layout) {
        this.state.layout = layout;
        this.adjustLayout();
        this.closeModal('layoutSelectorModal');
        this.saveState();
    }

    adjustLayout() {
        const grid = document.getElementById('dashboardGrid');
        
        // ê¸°ì¡´ í´ë˜ìŠ¤ ì œê±°
        grid.className = 'dashboard-grid';
        
        // ìƒˆ ë ˆì´ì•„ì›ƒ ì ìš©
        switch(this.state.layout) {
            case '1x1':
                grid.classList.add('grid-1x1');
                break;
            case '2x2':
                grid.classList.add('grid-2x2');
                break;
            case '3x3':
                grid.classList.add('grid-3x3');
                break;
            case '4x4':
                grid.classList.add('grid-4x4');
                break;
            case 'auto':
            default:
                // ìë™ ì¡°ì • (ê¸°ë³¸ê°’)
                break;
        }
    }

    async saveLayout() {
        const layoutName = prompt('ë ˆì´ì•„ì›ƒ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:');
        if (!layoutName) return;

        const layoutData = {
            name: layoutName,
            layout: {
                selectedTags: this.state.selectedTags,
                gridLayout: this.state.layout,
                autoRefresh: this.state.autoRefresh,
                refreshInterval: this.state.refreshInterval
            }
        };

        try {
            const response = await fetch(`${this.apiBaseUrl}/layouts`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(layoutData)
            });

            const result = await response.json();
            
            if (result.success) {
                this.showNotification('ë ˆì´ì•„ì›ƒì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                await this.loadSavedLayouts();
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            console.error('ë ˆì´ì•„ì›ƒ ì €ì¥ ì‹¤íŒ¨:', error);
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ë°±ì—… ì €ì¥
            this.saveLayoutLocally(layoutData);
        }
    }

    saveLayoutLocally(layoutData) {
        const layouts = JSON.parse(localStorage.getItem('dcs_layouts') || '[]');
        layouts.push({
            ...layoutData,
            createdAt: new Date().toISOString()
        });
        localStorage.setItem('dcs_layouts', JSON.stringify(layouts));
        this.showNotification('ë ˆì´ì•„ì›ƒì´ ë¡œì»¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    }

    async loadLayout() {
        if (this.savedLayouts.length === 0) {
            this.showNotification('ì €ì¥ëœ ë ˆì´ì•„ì›ƒì´ ì—†ìŠµë‹ˆë‹¤.', 'info');
            return;
        }

        const layoutList = this.savedLayouts.map((l, i) => `${i + 1}. ${l.name}`).join('\n');
        const selection = prompt(`ë¶ˆëŸ¬ì˜¬ ë ˆì´ì•„ì›ƒì„ ì„ íƒí•˜ì„¸ìš”:\n${layoutList}`);
        
        if (!selection) return;
        
        const index = parseInt(selection) - 1;
        if (index >= 0 && index < this.savedLayouts.length) {
            const layout = this.savedLayouts[index].layout;
            
            this.state.selectedTags = layout.selectedTags || [];
            this.state.layout = layout.gridLayout || 'auto';
            this.state.autoRefresh = layout.autoRefresh || false;
            this.state.refreshInterval = layout.refreshInterval || 10000;
            
            this.renderWidgets();
            this.adjustLayout();
            
            if (this.state.autoRefresh) {
                this.startAutoRefresh();
            }
            
            this.refreshData();
            this.showNotification('ë ˆì´ì•„ì›ƒì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.', 'success');
        }
    }

    async loadSavedLayouts() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/layouts`);
            const result = await response.json();
            
            if (result.success) {
                this.savedLayouts = result.layouts;
            }
        } catch (error) {
            console.error('ì €ì¥ëœ ë ˆì´ì•„ì›ƒ ë¡œë“œ ì‹¤íŒ¨:', error);
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œ
            this.savedLayouts = JSON.parse(localStorage.getItem('dcs_layouts') || '[]');
        }
        
        return this.savedLayouts;
    }

    // ìœ„ì ¯ ì œê±°
    removeWidget(tagName) {
        if (confirm(`${tagName} ìœ„ì ¯ì„ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
            // ì„ íƒëœ íƒœê·¸ì—ì„œ ì œê±°
            this.state.selectedTags = this.state.selectedTags.filter(t => t !== tagName);
            
            // SSE ì—°ê²° ì¢…ë£Œ
            if (this.state.eventSources.has(tagName)) {
                this.state.eventSources.get(tagName).close();
                this.state.eventSources.delete(tagName);
            }
            
            // ì°¨íŠ¸ ë°ì´í„° ì œê±°
            this.state.chartData.delete(tagName);
            
            // ìœ„ì ¯ ì œê±°
            this.state.widgets.delete(tagName);
            
            // DOMì—ì„œ ì œê±°
            const widget = document.getElementById(`widget-${tagName.replace(/[^a-z0-9]/gi, '-')}`);
            if (widget) {
                widget.remove();
            }
            
            this.saveState();
            this.showNotification(`${tagName} ìœ„ì ¯ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
        }
    }

    // ì°¨íŠ¸ íƒ€ì… ë³€ê²½
    toggleChartType(tagName) {
        const chartData = this.state.chartData.get(tagName);
        if (!chartData) return;
        
        const types = ['line', 'bar', 'area'];
        const currentIndex = types.indexOf(chartData.chartType || 'line');
        const newType = types[(currentIndex + 1) % types.length];
        
        chartData.chartType = newType;
        
        // ì°¨íŠ¸ íƒ€ì… ë³€ê²½
        if (newType === 'area') {
            chartData.chart.data.datasets[0].fill = true;
            chartData.chart.config.type = 'line';
        } else if (newType === 'bar') {
            chartData.chart.config.type = 'bar';
        } else {
            chartData.chart.data.datasets[0].fill = false;
            chartData.chart.config.type = 'line';
        }
        
        chartData.chart.update();
    }

    // ìƒíƒœ ê´€ë¦¬
    saveState() {
        const state = {
            selectedTags: this.state.selectedTags,
            layout: this.state.layout,
            autoRefresh: this.state.autoRefresh,
            refreshInterval: this.state.refreshInterval
        };
        
        localStorage.setItem('dcs_dashboard_state', JSON.stringify(state));
    }

    loadPreviousState() {
        const savedState = localStorage.getItem('dcs_dashboard_state');
        if (savedState) {
            try {
                const state = JSON.parse(savedState);
                this.state.selectedTags = state.selectedTags || [];
                this.state.layout = state.layout || 'auto';
                this.state.autoRefresh = state.autoRefresh || false;
                this.state.refreshInterval = state.refreshInterval || 10000;
                
                // UI ìƒíƒœ ë³µì›
                if (this.state.autoRefresh) {
                    document.getElementById('autoRefreshToggle').classList.add('active');
                }
            } catch (error) {
                console.error('ìƒíƒœ ë³µì› ì‹¤íŒ¨:', error);
            }
        }
    }

    // UI í—¬í¼ í•¨ìˆ˜
    openTagSelector() {
        document.getElementById('tagSelectorModal').classList.add('active');
        this.loadAvailableTags();
    }

    openLayoutSelector() {
        document.getElementById('layoutSelectorModal').classList.add('active');
    }

    closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
    }

    updateConnectionStatus(status) {
        this.state.connectionStatus = status;
        const statusDot = document.getElementById('connectionStatus');
        const statusText = document.getElementById('connectionText');
        
        if (status === 'connected') {
            statusDot.className = 'status-dot connected';
            statusText.textContent = 'ì—°ê²°ë¨';
        } else {
            statusDot.className = 'status-dot disconnected';
            statusText.textContent = 'ì—°ê²° ëŠê¹€';
        }
    }

    showNotification(message, type = 'info') {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = `notification show ${type}`;
        
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }
}

// ëŒ€ì‹œë³´ë“œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
let dashboard;

document.addEventListener('DOMContentLoaded', () => {
    dashboard = new DCSRealTimeDashboard();
});

// ì „ì—­ í•¨ìˆ˜ (HTMLì—ì„œ í˜¸ì¶œìš©)
window.dashboard = {
    openTagSelector: () => dashboard?.openTagSelector(),
    openLayoutSelector: () => dashboard?.openLayoutSelector(),
    closeModal: (id) => dashboard?.closeModal(id),
    saveLayout: () => dashboard?.saveLayout(),
    loadLayout: () => dashboard?.loadLayout(),
    refreshData: () => dashboard?.refreshData(),
    refreshTag: (tag) => dashboard?.refreshTag(tag),
    removeWidget: (tag) => dashboard?.removeWidget(tag),
    toggleAutoRefresh: () => dashboard?.toggleAutoRefresh(),
    setLayout: (layout) => dashboard?.setLayout(layout),
    loadAvailableTags: () => dashboard?.loadAvailableTags(),
    applySelectedTags: () => dashboard?.applySelectedTags(),
    toggleChartType: (tag) => dashboard?.toggleChartType(tag)
};